{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixel-distorsion-demo",
  "type": "registry:ui",
  "title": "Pixel Distorsion Shader",
  "description": "An interactive and customizable shader effect that distorts pixels dynamically based on mouse interactions, perfect for creating engaging and immersive visual effects on images.",
  "dependencies": [
    "@react-three/fiber",
    "@react-three/drei",
    "gsap"
  ],
  "files": [
    {
      "path": "registry/demos/pixel-distorsion-demo.tsx",
      "content": "\"use client\";\r\n\r\nimport dynamic from \"next/dynamic\";\r\nconst PixelDistorsionScene = dynamic(\r\n  () => import(\"@/registry/components/shaders/pixel-distorsion-scene\"),\r\n  {\r\n    ssr: false,\r\n    loading: () => (\r\n      <div className=\"h-full w-full bg-zinc-100 dark:bg-neutral-950\">\r\n        {/* Skeleton loader */}\r\n      </div>\r\n    ),\r\n  }\r\n);\r\n\r\nexport default function MouseWaveDemo() {\r\n  return (\r\n    <div className=\" w-full max-w-[900px] h-auto flex items-center justify-center\">\r\n      <PixelDistorsionScene imageSrc=\"https://cdn.badtz-ui.com/images/shaders/medusa-image.webp\" />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/components/shaders/pixel-distorsion-scene.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useState, useRef, useCallback } from \"react\";\r\nimport PixelDistorsion from \"@/components/ui/pixel-distorsion\";\r\nimport { Canvas } from \"@react-three/fiber\";\r\nimport * as THREE from \"three\";\r\n\r\ninterface PixelDistorsionSceneProps {\r\n  imageSrc: string;\r\n  alt?: string;\r\n  grid?: number;\r\n  mouse?: number;\r\n  strength?: number;\r\n}\r\n\r\nexport default function PixelDistorsionScene({\r\n  imageSrc,\r\n  alt,\r\n  grid = 20,\r\n  mouse = 0.25,\r\n  strength = 0.2,\r\n}: PixelDistorsionSceneProps) {\r\n  const [isMobile, setIsMobile] = useState(window.innerWidth < 768);\r\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\r\n  const [key, setKey] = useState(0);\r\n\r\n  const updateDimensions = useCallback(() => {\r\n    if (!containerRef.current || !window) return;\r\n\r\n    const parentWidth = Math.max(1, containerRef.current.clientWidth || 1);\r\n    setIsMobile(window.innerWidth < 640);\r\n    const img = new Image();\r\n    img.src = imageSrc;\r\n    img.onload = () => {\r\n      const aspect = img.width / img.height;\r\n      const newHeight = parentWidth / aspect;\r\n      setDimensions({ width: parentWidth, height: newHeight });\r\n\r\n      if (!isMobile) {\r\n        const newDistance = newHeight / 2 / Math.tan((45 * Math.PI) / 360);\r\n        if (cameraRef.current) {\r\n          cameraRef.current.position.set(0, 0, newDistance);\r\n          cameraRef.current.updateProjectionMatrix();\r\n        }\r\n      }\r\n    };\r\n  }, [imageSrc, isMobile]);\r\n\r\n  useEffect(() => {\r\n    updateDimensions();\r\n    const observer = new ResizeObserver(() => {\r\n      requestAnimationFrame(updateDimensions);\r\n    });\r\n    window.addEventListener(\"resize\", updateDimensions);\r\n\r\n    if (containerRef.current) observer.observe(containerRef.current);\r\n    return () => {\r\n      observer.disconnect();\r\n      window.removeEventListener(\"resize\", updateDimensions);\r\n    };\r\n  }, [updateDimensions]);\r\n\r\n  useEffect(() => {\r\n    const timer = setTimeout(() => {\r\n      setKey(1);\r\n    }, 100);\r\n\r\n    return () => clearTimeout(timer);\r\n  }, []);\r\n\r\n  const handleCanvasCreated = useCallback(\r\n    ({ camera }: { camera: THREE.Camera }) => {\r\n      cameraRef.current = camera as THREE.PerspectiveCamera;\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      style={{ width: \"100%\", height: dimensions.height }}\r\n    >\r\n      {isMobile ? (\r\n        <img\r\n          src={imageSrc}\r\n          alt={alt || \"Shader preview\"}\r\n          style={{ width: \"100%\", height: \"100%\", objectFit: \"cover\" }}\r\n        />\r\n      ) : (\r\n        <Canvas\r\n          key={key}\r\n          camera={{\r\n            fov: 45,\r\n            aspect: dimensions.width / dimensions.height,\r\n            near: 0.1,\r\n            far: 1000,\r\n            position: [\r\n              0,\r\n              0,\r\n              dimensions.height / 2 / Math.tan((45 * Math.PI) / 360),\r\n            ],\r\n          }}\r\n          onCreated={handleCanvasCreated}\r\n          style={{ width: \"100%\", height: \"100%\" }}\r\n        >\r\n          <PixelDistorsion\r\n            imageSrc={imageSrc}\r\n            canvasWidth={dimensions.width}\r\n            canvasHeight={dimensions.height}\r\n            grid={grid}\r\n            mouse={mouse}\r\n            strength={strength}\r\n          />\r\n        </Canvas>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/components/shaders/pixel-distorsion-shader.tsx",
      "content": "export const vertex = `\r\nuniform float time;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\nuniform vec2 pixels;\r\nfloat PI = 3.141592653589793238;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n`;\r\n\r\nexport const fragment = `\r\nuniform sampler2D uDataTexture;\r\nuniform sampler2D uTexture;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\r\n    vec4 offset = texture2D(uDataTexture, vUv);\r\n    gl_FragColor = texture2D(uTexture, newUV - 0.02*offset.rg);\r\n}\r\n`;\r\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/components/shaders/pixel-distorsion.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useRef, useEffect, useCallback } from \"react\";\r\nimport { fragment, vertex } from \"@/components/ui/pixel-distorsion-shader\";\r\nimport { useFrame, ThreeEvent } from \"@react-three/fiber\";\r\nimport { useTexture } from \"@react-three/drei\";\r\nimport * as THREE from \"three\";\r\n\r\ninterface PixelDistorsionProps {\r\n  imageSrc: string;\r\n  canvasWidth: number;\r\n  canvasHeight: number;\r\n  grid?: number;\r\n  mouse?: number;\r\n  strength?: number;\r\n}\r\n\r\nexport default function PixelDistorsion({\r\n  imageSrc,\r\n  canvasWidth,\r\n  canvasHeight,\r\n  grid = 20,\r\n  mouse = 0.25,\r\n  strength = 0.2,\r\n}: PixelDistorsionProps) {\r\n  const plane = useRef<THREE.Mesh>(null);\r\n  const texture = useTexture(imageSrc);\r\n  const mouseState = useRef({ x: 0.5, y: 0.5, vX: 0, vY: 0 });\r\n\r\n  const uniforms = useRef({\r\n    uTexture: { value: texture },\r\n    uTime: { value: 0 },\r\n    uHover: { value: new THREE.Vector2(0.5, 0.5) },\r\n    uDataTexture: { value: null as THREE.DataTexture | null },\r\n    resolution: { value: new THREE.Vector4() },\r\n  });\r\n\r\n  const generateDataTexture = useCallback(() => {\r\n    const data = new Float32Array(grid * grid * 4);\r\n    for (let i = 0; i < grid * grid; i++) {\r\n      const stride = i * 4;\r\n      data[stride] = Math.random();\r\n      data[stride + 1] = Math.random();\r\n      data[stride + 2] = Math.random();\r\n      data[stride + 3] = 1.0;\r\n    }\r\n    const dataTexture = new THREE.DataTexture(\r\n      data,\r\n      grid,\r\n      grid,\r\n      THREE.RGBAFormat,\r\n      THREE.FloatType\r\n    );\r\n    dataTexture.needsUpdate = true;\r\n    dataTexture.minFilter = THREE.NearestFilter;\r\n    dataTexture.magFilter = THREE.NearestFilter;\r\n    return dataTexture;\r\n  }, [grid]);\r\n\r\n  useEffect(() => {\r\n    uniforms.current.uDataTexture.value = generateDataTexture();\r\n  }, [generateDataTexture]);\r\n\r\n  useEffect(() => {\r\n    uniforms.current.resolution.value.set(canvasWidth, canvasHeight, 1, 1);\r\n  }, [canvasWidth, canvasHeight]);\r\n\r\n  const settings = { grid, mouseInfluence: mouse, strength, relaxation: 0.9 };\r\n\r\n  const clamp = (number: number, min: number, max: number) =>\r\n    Math.max(min, Math.min(number, max));\r\n\r\n  const updateDataTexture = () => {\r\n    const dataTexture = uniforms.current.uDataTexture?.value;\r\n    if (!dataTexture || !dataTexture.image?.data) return;\r\n\r\n    const data = dataTexture.image.data as Float32Array;\r\n    const gridMouseX = mouseState.current.x * settings.grid;\r\n    const gridMouseY = (1 - mouseState.current.y) * settings.grid;\r\n    const maxDist = settings.grid * settings.mouseInfluence;\r\n    const aspect = canvasHeight / canvasWidth;\r\n\r\n    for (let i = 0; i < data.length; i += 4) {\r\n      data[i] *= settings.relaxation;\r\n      data[i + 1] *= settings.relaxation;\r\n    }\r\n\r\n    for (let i = 0; i < settings.grid; i++) {\r\n      for (let j = 0; j < settings.grid; j++) {\r\n        const distance = (gridMouseX - i) ** 2 / aspect + (gridMouseY - j) ** 2;\r\n        const maxDistSq = maxDist ** 2;\r\n\r\n        if (distance < maxDistSq) {\r\n          const index = 4 * (i + settings.grid * j);\r\n          let power = maxDist / Math.sqrt(distance);\r\n          power = clamp(power, 0, 10);\r\n\r\n          data[index] +=\r\n            settings.strength * mouseState.current.vX * power * 100;\r\n          data[index + 1] -=\r\n            settings.strength * mouseState.current.vY * power * 100;\r\n        }\r\n      }\r\n    }\r\n    mouseState.current.vX *= 0.9;\r\n    mouseState.current.vY *= 0.9;\r\n\r\n    requestAnimationFrame(() => {\r\n      if (dataTexture) dataTexture.needsUpdate = true;\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    const dataTexture = generateDataTexture();\r\n    uniforms.current.uDataTexture.value = dataTexture;\r\n\r\n    return () => {\r\n      dataTexture?.dispose();\r\n      texture?.dispose();\r\n    };\r\n  }, [generateDataTexture, texture]);\r\n\r\n  const handlePointerMove = (event: ThreeEvent<PointerEvent>) => {\r\n    const { offsetX, offsetY } = event.nativeEvent;\r\n    mouseState.current.vX = offsetX / canvasWidth - mouseState.current.x;\r\n    mouseState.current.vY = offsetY / canvasHeight - mouseState.current.y;\r\n    mouseState.current.x = offsetX / canvasWidth;\r\n    mouseState.current.y = offsetY / canvasHeight;\r\n  };\r\n\r\n  useFrame((state) => {\r\n    if (plane.current) {\r\n      (plane.current.material as THREE.ShaderMaterial).uniforms.uTime.value =\r\n        state.clock.elapsedTime;\r\n      updateDataTexture();\r\n    }\r\n  });\r\n\r\n  return (\r\n    <mesh ref={plane} onPointerMove={handlePointerMove}>\r\n      <planeGeometry args={[canvasWidth, canvasHeight, 45, 45]} />\r\n      <shaderMaterial\r\n        side={THREE.DoubleSide}\r\n        vertexShader={vertex}\r\n        fragmentShader={fragment}\r\n        uniforms={uniforms.current}\r\n      />\r\n    </mesh>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    }
  ]
}