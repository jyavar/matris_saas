{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-split",
  "type": "registry:ui",
  "title": "Image Split",
  "description": "This component provides a dynamic and visually captivating way to display images split into multiple sections.",
  "files": [
    {
      "path": "registry/components/image-split.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useState, useRef, useEffect } from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface ImageSplitProps extends React.HTMLAttributes<HTMLDivElement> {\r\n  src: string;\r\n  sections?: number;\r\n  offsetStep?: number;\r\n  initialBorderOpacity?: number;\r\n  enableBorder?: boolean;\r\n  borderColor?: string;\r\n  viewportThreshold?: number;\r\n  className?: string;\r\n}\r\n\r\nconst hexToRgb = (hex: string): string | null => {\r\n  const validHex = /^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/.test(hex);\r\n  if (!validHex) return null;\r\n\r\n  let cleanHex = hex.replace(\"#\", \"\");\r\n\r\n  if (cleanHex.length === 3) {\r\n    cleanHex = cleanHex\r\n      .split(\"\")\r\n      .map((char) => char + char)\r\n      .join(\"\");\r\n  }\r\n\r\n  const bigint = parseInt(cleanHex, 16);\r\n  const r = (bigint >> 16) & 255;\r\n  const g = (bigint >> 8) & 255;\r\n  const b = bigint & 255;\r\n\r\n  return `${r}, ${g}, ${b}`;\r\n};\r\n\r\nexport function ImageSplit({\r\n  src,\r\n  sections = 9,\r\n  offsetStep = 30,\r\n  initialBorderOpacity = 0.4,\r\n  enableBorder = true,\r\n  borderColor = \"#ffffff\",\r\n  viewportThreshold = 0.3,\r\n  className,\r\n  ...props\r\n}: ImageSplitProps) {\r\n  const [imagePieces, setImagePieces] = useState<string[]>([]);\r\n  const [borderOpacity, setBorderOpacity] =\r\n    useState<number>(initialBorderOpacity);\r\n  const [progress, setProgress] = useState<number>(0);\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const parentRef = useRef<HTMLDivElement | null>(null);\r\n  const imgRefs = useRef<(HTMLImageElement | null)[]>([]);\r\n  const scrollContainerRef = useRef<HTMLElement | null>(null);\r\n  const animationFrameRef = useRef<number>();\r\n  const borderRgb = hexToRgb(borderColor) || \"255, 255, 255\";\r\n\r\n  useEffect(() => {\r\n    const image = new Image();\r\n    image.src = src;\r\n    image.onload = () => cutImageUp(image);\r\n  }, [src, sections]);\r\n\r\n  useEffect(() => {\r\n    setBorderOpacity(progress * initialBorderOpacity);\r\n  }, [progress]);\r\n\r\n  useEffect(() => {\r\n    const parent = parentRef.current;\r\n    if (!parent) return;\r\n\r\n    scrollContainerRef.current = getScrollParent(parent);\r\n    setupScrollListener();\r\n\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const getScrollParent = (element: HTMLElement | null): HTMLElement | null => {\r\n    while (element) {\r\n      const style = getComputedStyle(element);\r\n      if ([\"auto\", \"scroll\"].includes(style.overflowY)) return element;\r\n      if (!element.parentElement) return null;\r\n      element = element.parentElement;\r\n    }\r\n    return null;\r\n  };\r\n\r\n  const setupScrollListener = () => {\r\n    const scrollContainer = scrollContainerRef.current;\r\n    const parent = parentRef.current;\r\n    if (!parent) return;\r\n\r\n    const updateProgress = () => {\r\n      const parentRect = parent.getBoundingClientRect();\r\n      const viewportHeight = window.innerHeight;\r\n\r\n      let progress;\r\n      if (scrollContainer instanceof HTMLElement) {\r\n        const scrollContainerRect = scrollContainer.getBoundingClientRect();\r\n        const start = scrollContainerRect.bottom;\r\n        const end =\r\n          scrollContainerRect.top + viewportHeight * viewportThreshold;\r\n        const current = parentRect.top;\r\n        progress = (current - end) / (start - end);\r\n      } else {\r\n        const startTrigger = viewportHeight * viewportThreshold;\r\n        const elementTop = parentRect.top;\r\n        const elementHeight = parentRect.height;\r\n\r\n        progress =\r\n          (elementTop - startTrigger) /\r\n          (viewportHeight - elementHeight - startTrigger);\r\n      }\r\n\r\n      progress = Math.min(1, Math.max(0, progress));\r\n      setProgress(progress);\r\n\r\n      imgRefs.current.forEach((img, index) => {\r\n        if (!img) return;\r\n        const offset = getOffset(index);\r\n        img.style.transform = `translateY(${offset * progress}px)`;\r\n      });\r\n    };\r\n\r\n    const handleScroll = () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n      animationFrameRef.current = requestAnimationFrame(updateProgress);\r\n    };\r\n\r\n    const target = scrollContainer || window;\r\n    target.addEventListener(\"scroll\", handleScroll, { passive: true });\r\n    handleScroll();\r\n\r\n    return () => target.removeEventListener(\"scroll\", handleScroll);\r\n  };\r\n\r\n  const cutImageUp = (image: HTMLImageElement) => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const pieceWidth = Math.floor(image.width / sections);\r\n    const pieceHeight = image.height;\r\n    const context = canvas.getContext(\"2d\");\r\n    if (!context) return;\r\n\r\n    const newImagePieces: string[] = [];\r\n    for (let i = 0; i < sections; i++) {\r\n      canvas.width = pieceWidth;\r\n      canvas.height = pieceHeight;\r\n      context.clearRect(0, 0, canvas.width, canvas.height);\r\n      context.drawImage(\r\n        image,\r\n        i * pieceWidth,\r\n        0,\r\n        pieceWidth,\r\n        pieceHeight,\r\n        0,\r\n        0,\r\n        pieceWidth,\r\n        pieceHeight\r\n      );\r\n      newImagePieces.push(canvas.toDataURL());\r\n    }\r\n    setImagePieces(newImagePieces);\r\n  };\r\n\r\n  const getOffset = (index: number) => {\r\n    if (index === 0 || index === sections - 1) return 0;\r\n    return Math.min(index, sections - 1 - index) * offsetStep;\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={parentRef}\r\n      className={cn(\"flex relative w-full rounded-[inherit]\", className)}\r\n      {...props}\r\n    >\r\n      <canvas ref={canvasRef} className=\"hidden\" />\r\n\r\n      {imagePieces.map((piece, index) => (\r\n        <img\r\n          key={index}\r\n          src={piece}\r\n          alt={`section-${index}`}\r\n          ref={(el: HTMLImageElement | null) => {\r\n            imgRefs.current[index] = el;\r\n          }}\r\n          className={cn(\r\n            \"object-contain transition-transform duration-300 ease-out\",\r\n            {\r\n              \"rounded-l-[inherit]\": index === 0,\r\n              \"rounded-r-[inherit]\": index === imagePieces.length - 1,\r\n            }\r\n          )}\r\n          style={{\r\n            width: `${100 / sections}%`,\r\n            transform: `translateY(${getOffset(index)}px)`,\r\n            zIndex: sections - index,\r\n            borderRight:\r\n              enableBorder && index !== imagePieces.length - 1\r\n                ? `1px solid rgba(${borderRgb}, ${borderOpacity})`\r\n                : \"none\",\r\n            marginRight:\r\n              enableBorder && index !== imagePieces.length - 1 ? \"-1px\" : \"0\",\r\n            boxSizing: \"border-box\",\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    }
  ]
}