{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hyperspace-background",
  "type": "registry:ui",
  "title": "Hyperspace Background",
  "description": "A dynamic and customizable background component that simulates a star-filled hyperspace effect.",
  "files": [
    {
      "path": "registry/components/backgrounds/hyperspace-background.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface HyperspaceBackgroundProps\r\n  extends React.HTMLAttributes<HTMLDivElement> {\r\n  starTrailOpacity?: number;\r\n  starSpeed?: number;\r\n  starColor?: string;\r\n  starSize?: number;\r\n  className?: string;\r\n}\r\n\r\ninterface StarState {\r\n  alpha: number;\r\n  angle: number;\r\n  x: number;\r\n  vX: number;\r\n  y: number;\r\n  vY: number;\r\n  size: number;\r\n  active: boolean;\r\n}\r\n\r\nfunction hexToRgb(hex: string): [number, number, number] {\r\n  const cleanedHex = hex.replace(\"#\", \"\");\r\n  const bigint = parseInt(cleanedHex, 16);\r\n  const r = (bigint >> 16) & 255;\r\n  const g = (bigint >> 8) & 255;\r\n  const b = bigint & 255;\r\n  return [r, g, b];\r\n}\r\n\r\nfunction randomInRange(max: number, min: number) {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function HyperspaceBackground({\r\n  starTrailOpacity = 0.5,\r\n  starSpeed = 1.01,\r\n  starColor = \"#FFFFFF\",\r\n  starSize = 0.5,\r\n  className,\r\n  ...props\r\n}: HyperspaceBackgroundProps) {\r\n  const canvasRef = React.useRef<HTMLCanvasElement | null>(null);\r\n  const [r, g, b] = hexToRgb(starColor);\r\n\r\n  React.useEffect(() => {\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    const context = canvas.getContext(\"2d\");\r\n    if (!context) return;\r\n\r\n    const resizeCanvas = () => {\r\n      const container = canvas.parentElement;\r\n      if (container) {\r\n        canvas.width = container.offsetWidth;\r\n        canvas.height = container.offsetHeight;\r\n      }\r\n    };\r\n\r\n    const debounceResize = () => {\r\n      let timeout: NodeJS.Timeout;\r\n      return () => {\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(resizeCanvas, 100);\r\n      };\r\n    };\r\n\r\n    resizeCanvas();\r\n\r\n    const sizeIncrement = 1.01;\r\n    const radians = Math.PI / 180;\r\n\r\n    class Star {\r\n      state: StarState;\r\n\r\n      constructor() {\r\n        this.state = {\r\n          alpha: 0,\r\n          angle: 0,\r\n          x: 0,\r\n          vX: 0,\r\n          y: 0,\r\n          vY: 0,\r\n          size: starSize,\r\n          active: true,\r\n        };\r\n        this.reset();\r\n      }\r\n\r\n      reset() {\r\n        const angle = randomInRange(0, 360) * radians;\r\n        const vX = Math.cos(angle);\r\n        const vY = Math.sin(angle);\r\n\r\n        if (!canvas) return;\r\n\r\n        const travelled =\r\n          Math.random() > 0.5\r\n            ? Math.random() * Math.max(canvas.width, canvas.height) +\r\n              Math.random() * (canvas.width * 0.24)\r\n            : Math.random() * (canvas.width * 0.25);\r\n\r\n        this.state = {\r\n          alpha: Math.random(),\r\n          angle: randomInRange(0, 360) * radians,\r\n          x: Math.floor(vX * travelled) + canvas.width / 2,\r\n          vX,\r\n          y: Math.floor(vY * travelled) + canvas.height / 2,\r\n          vY,\r\n          size: starSize,\r\n          active: true,\r\n        };\r\n      }\r\n    }\r\n\r\n    const stars = new Array(300).fill(null).map(() => new Star());\r\n\r\n    let animationFrameId: number;\r\n    const render = () => {\r\n      const invertedOpacity = 1 - starTrailOpacity;\r\n      context.fillStyle = `rgba(0, 0, 0, ${invertedOpacity})`;\r\n      context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n      for (const star of stars) {\r\n        const { x, y, size, vX, vY } = star.state;\r\n\r\n        const newX = x + vX;\r\n        const newY = y + vY;\r\n\r\n        if (\r\n          newX < 0 ||\r\n          newX > canvas.width ||\r\n          newY < 0 ||\r\n          newY > canvas.height\r\n        ) {\r\n          star.reset();\r\n        } else {\r\n          star.state = {\r\n            ...star.state,\r\n            x: newX,\r\n            vX: star.state.vX * starSpeed,\r\n            y: newY,\r\n            vY: star.state.vY * starSpeed,\r\n            size: size * sizeIncrement,\r\n          };\r\n\r\n          context.strokeStyle = `rgba(${r}, ${g}, ${b}, ${star.state.alpha})`;\r\n          context.lineWidth = size;\r\n          context.beginPath();\r\n          context.moveTo(x, y);\r\n          context.lineTo(star.state.x, star.state.y);\r\n          context.stroke();\r\n        }\r\n      }\r\n\r\n      animationFrameId = requestAnimationFrame(render);\r\n    };\r\n\r\n    render();\r\n\r\n    const debouncedResize = debounceResize();\r\n    window.addEventListener(\"resize\", debouncedResize);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animationFrameId);\r\n      window.removeEventListener(\"resize\", debouncedResize);\r\n    };\r\n  }, [starTrailOpacity, starSpeed, starColor, starSize]);\r\n\r\n  return (\r\n    <div className={cn(\"absolute inset-0 w-full h-full\", className)} {...props}>\r\n      <canvas ref={canvasRef} className=\"absolute inset-0 w-full h-full\" />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    }
  ]
}