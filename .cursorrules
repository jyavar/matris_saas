# STRATO Core OS‚Ñ¢ - Cursor Rules

## üèóÔ∏è ARQUITECTURA DEL PROYECTO

STRATO es un monorepo SaaS con arquitectura modular:

```
matriz_cursor/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ backend/          # API Node.js puro + Supabase (puerto 3001)
‚îÇ   ‚îú‚îÄ‚îÄ backend-nest/     # API NestJS + Supabase (puerto 3002)
‚îÇ   ‚îú‚îÄ‚îÄ frontend/         # React + Vite + TypeScript
‚îÇ   ‚îî‚îÄ‚îÄ web/             # Next.js Landing + Control Tower
‚îú‚îÄ‚îÄ packages/             # Librer√≠as compartidas
‚îú‚îÄ‚îÄ supabase/            # Base de datos y migraciones
‚îî‚îÄ‚îÄ scripts/             # Herramientas de desarrollo
```

## üéØ PATRONES Y CONVENCIONES

### Backend (Node.js puro)
- **Controllers**: Manejan requests/responses HTTP nativos, validaci√≥n, logging
- **Services**: L√≥gica de negocio, integraci√≥n con APIs externas
- **Router**: Router modular personalizado para rutas din√°micas
- **Middleware**: Auth, error handling, logging
- **Types**: Tipos TypeScript para Supabase y HTTP nativo

### Frontend (React/Vite)
- **Components**: Reutilizables en `/components/ui/`
- **Pages**: P√°ginas principales en `/app/`
- **Services**: APIs y servicios externos
- **Contexts**: Estado global (AuthContext)
- **Hooks**: L√≥gica reutilizable

### Web (Next.js)
- **App Router**: Estructura moderna de Next.js 15
- **API Routes**: Endpoints para auditor√≠a y control
- **Components**: Landing page y Control Tower

## üîß TECNOLOG√çAS PRINCIPALES

### Backend
- **Node.js puro**: API REST con HTTP nativo
- **TypeScript**: Tipado est√°tico
- **Supabase**: Base de datos PostgreSQL + Auth (modular)
- **Stripe**: Pagos
- **OpenAI**: IA
- **PostHog**: Analytics
- **Resend**: Email
- **Pino**: Logging estructurado

### Frontend
- **React 18**: UI Framework
- **Vite**: Build tool
- **TypeScript**: Tipado est√°tico
- **Tailwind CSS**: Estilos
- **Vitest**: Testing
- **MSW**: Mock Service Worker

### Web
- **Next.js 15**: Framework React
- **App Router**: Enrutamiento moderno
- **TypeScript**: Tipado est√°tico

## üìù CONVENCIONES DE C√ìDIGO

### Naming
- **Files**: kebab-case (auth.controller.ts)
- **Functions**: camelCase (getUserProfile)
- **Classes**: PascalCase (AuthService)
- **Constants**: UPPER_SNAKE_CASE (API_BASE_URL)
- **Types**: PascalCase (UserProfile)

### Imports
- **Relative**: Para archivos del mismo m√≥dulo
- **Absolute**: Para paquetes externos
- **Workspace**: Para paquetes internos (@repo/db-types)

### Error Handling
- **Controllers**: Try/catch con manejo de errores centralizado
- **Services**: Throw ApiError con c√≥digos HTTP
- **Frontend**: Error boundaries y estados de error

### Logging
- **Structured**: Pino con contexto estructurado
- **Actions**: logAction() para eventos de negocio
- **Levels**: info, warn, error seg√∫n severidad

## üß™ TESTING STANDARDS - ESTRATEGIA GLOBAL

### üéØ OBJETIVOS PRINCIPALES
Los tests en STRATO deben:
1. **Ser realistas** - Reflejar la l√≥gica de negocio esperada
2. **Pasar desde el primer intento** - Sin debugging innecesario
3. **Ser unitarios puros** - Sin dependencias externas (Supabase, Stripe, OpenAI, etc.)
4. **Usar mocks apropiados** - `vi.mock()` o `msw` para evitar IO real
5. **Ser ultra-r√°pidos** - Idealmente <5 segundos por suite
6. **Manejar errores expl√≠citamente** - ZodError debe devolver 400, no 500
7. **Validar inputs num√©ricos** - `limit`, `offset`, `user_id`, etc.
8. **Cubrir flujos positivos y negativos** - Sin repetir l√≥gica
9. **Tener estructura clara** - `describe/it` bien organizado
10. **Cumplir reglas de calidad** - `.cursorrules` y `eslint`

### üìä M√âTRICAS DE CALIDAD
- **Performance**: <5 segundos por suite de tests
- **Cobertura**: ‚â•90% l√≠neas y branches
- **Fiabilidad**: 100% de tests pasando consistentemente
- **Mantenibilidad**: Tests legibles y bien estructurados

### üèóÔ∏è ARQUITECTURA DE TESTS

#### Backend Tests (Vitest + Supertest)
```ts
// Estructura recomendada
describe('POST /api/campaigns', () => {
  // Factories para datos consistentes
  const createTestCampaign = (overrides = {}) => ({
    title: 'Test Campaign',
    description: 'Test Description',
    budget: 1000,
    ...overrides
  })

  // Mocks globales
  const mockCampaignService = {
    create: vi.fn(),
    update: vi.fn(),
    delete: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
    // Configurar mocks espec√≠ficos
  })

  it('should create campaign with valid data', async () => {
    // Arrange
    const validData = createTestCampaign()
    const mockResponse = { id: 1, ...validData, created_at: new Date() }
    mockCampaignService.create.mockResolvedValue(mockResponse)

    // Act
    const startTime = Date.now()
    const response = await request(app)
      .post('/api/campaigns')
      .send(validData)
    const duration = Date.now() - startTime

    // Assert
    expect(duration).toBeLessThan(5000) // Performance check
    expect(response.status).toBe(201)
    expect(response.body).toMatchObject({
      success: true,
      data: expect.objectContaining({
        id: expect.any(Number),
        title: validData.title,
        budget: validData.budget
      })
    })
    expect(mockCampaignService.create).toHaveBeenCalledTimes(1)
    expect(mockCampaignService.create).toHaveBeenCalledWith(validData)
  })

  it('should return 400 for missing title', async () => {
    // Arrange
    const invalidData = createTestCampaign({ title: undefined })

    // Act
    const response = await request(app)
      .post('/api/campaigns')
      .send(invalidData)

    // Assert
    expect(response.status).toBe(400)
    expect(response.body.success).toBe(false)
    expect(response.body.error).toBeDefined()
  })

  it('should handle malformed JSON gracefully', async () => {
    // Act
    const response = await request(app)
      .post('/api/campaigns')
      .set('Content-Type', 'application/json')
      .send('{"invalid": json}')

    // Assert
    expect(response.status).toBe(400)
  })
})
```

#### Frontend Tests (Vitest + React Testing Library)
```tsx
// Estructura recomendada para componentes
describe('CampaignForm Component', () => {
  const renderCampaignForm = (props = {}) => {
    return render(
      <CampaignForm 
        onSubmit={vi.fn()}
        initialData={{}}
        {...props}
      />
    )
  }

  it('should render form fields correctly', () => {
    // Arrange & Act
    const { getByLabelText, getByRole } = renderCampaignForm()

    // Assert
    expect(getByLabelText(/title/i)).toBeInTheDocument()
    expect(getByLabelText(/budget/i)).toBeInTheDocument()
    expect(getByRole('button', { name: /submit/i })).toBeInTheDocument()
  })

  it('should call onSubmit with form data', async () => {
    // Arrange
    const mockOnSubmit = vi.fn()
    const { getByLabelText, getByRole } = renderCampaignForm({ onSubmit: mockOnSubmit })

    // Act
    await userEvent.type(getByLabelText(/title/i), 'Test Campaign')
    await userEvent.type(getByLabelText(/budget/i), '1000')
    await userEvent.click(getByRole('button', { name: /submit/i }))

    // Assert
    expect(mockOnSubmit).toHaveBeenCalledWith({
      title: 'Test Campaign',
      budget: 1000
    })
  })
})
```

### üîß MOCKING STRATEGY

#### Backend Mocks (Vitest)
```ts
// Mock de servicios externos
vi.mock('../services/supabase.service.js', () => ({
  supabase: {
    from: vi.fn(() => ({
      insert: vi.fn(() => ({
        select: vi.fn(() => Promise.resolve({ 
          data: [{ id: 1, name: 'test' }], 
          error: null 
        }))
      })),
      select: vi.fn(() => ({
        order: vi.fn(() => ({
          limit: vi.fn(() => ({
            range: vi.fn(() => Promise.resolve({ data: [], error: null }))
          }))
        }))
      }))
    }))
  }
}))

// Mock de middleware
vi.mock('../middleware/auth.middleware.js', () => ({
  authMiddleware: vi.fn((req, res, next) => {
    req.user = { id: 1, email: 'test@example.com' }
    next()
  })
}))

// Mock de servicios de terceros
vi.mock('stripe', () => ({
  default: vi.fn(() => ({
    paymentIntents: {
      create: vi.fn(() => Promise.resolve({ id: 'pi_test' }))
    }
  }))
}))
```

#### Frontend Mocks (MSW)
```ts
// handlers.ts
import { rest } from 'msw'

export const handlers = [
  rest.post('/api/campaigns', (req, res, ctx) => {
    return res(
      ctx.status(201),
      ctx.json({
        success: true,
        data: {
          id: 1,
          title: 'Test Campaign',
          created_at: new Date().toISOString()
        }
      })
    )
  }),

  rest.get('/api/campaigns', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        success: true,
        data: [
          { id: 1, title: 'Campaign 1' },
          { id: 2, title: 'Campaign 2' }
        ]
      })
    )
  })
]
```

### üìã CHECKLIST DE VALIDACI√ìN DE TESTS

#### Antes de crear tests:
- [ ] ¬øEl test refleja un caso de uso real?
- [ ] ¬øEst√°n mockeados todos los servicios externos?
- [ ] ¬øSe validan tanto casos positivos como negativos?
- [ ] ¬øSe manejan errores de validaci√≥n (ZodError ‚Üí 400)?
- [ ] ¬øSe validan inputs num√©ricos correctamente?
- [ ] ¬øEl test es independiente y no afecta otros tests?

#### Durante la implementaci√≥n:
- [ ] ¬øSe usan factories para datos consistentes?
- [ ] ¬øSe mide el tiempo de ejecuci√≥n (<5s)?
- [ ] ¬øSe validan las llamadas a mocks?
- [ ] ¬øSe verifica la estructura completa de respuesta?
- [ ] ¬øSe incluyen edge cases importantes?

#### Despu√©s de implementar:
- [ ] ¬øTodos los tests pasan consistentemente?
- [ ] ¬øLa cobertura es ‚â•90%?
- [ ] ¬øLos tests son legibles y mantenibles?
- [ ] ¬øSe documentan casos especiales?
- [ ] ¬øSe integran con CI/CD?

### üö´ ANTI-PATRONES DE TESTING

#### ‚ùå NO HACER
```ts
// ‚ùå Tests que dependen de servicios externos
it('should create user in database', async () => {
  const user = await createUserInRealDatabase() // MALO
})

// ‚ùå Tests lentos (>5 segundos)
it('should process large dataset', async () => {
  await processLargeDataset() // MALO - muy lento
})

// ‚ùå Tests que no validan estructura
it('should return success', async () => {
  const response = await request(app).post('/api/users')
  expect(response.status).toBe(200) // MALO - muy b√°sico
})

// ‚ùå Tests que no manejan errores
it('should handle invalid data', async () => {
  const response = await request(app).post('/api/users').send({})
  // No valida el error espec√≠fico - MALO
})

// ‚ùå Mocks incompletos
vi.mock('supabase', () => ({
  // Mock incompleto que causa errores - MALO
}))
```

#### ‚úÖ HACER
```ts
// ‚úÖ Tests con mocks apropiados
it('should create user successfully', async () => {
  const mockUser = { id: 1, email: 'test@example.com' }
  mockUserService.create.mockResolvedValue(mockUser)
  
  const response = await request(app).post('/api/users').send(validUserData)
  
  expect(response.status).toBe(201)
  expect(response.body.data).toMatchObject(mockUser)
  expect(mockUserService.create).toHaveBeenCalledWith(validUserData)
})

// ‚úÖ Tests r√°pidos con validaci√≥n completa
it('should validate user data', async () => {
  const startTime = Date.now()
  
  const response = await request(app).post('/api/users').send(invalidData)
  
  const duration = Date.now() - startTime
  expect(duration).toBeLessThan(1000) // <1s
  expect(response.status).toBe(400)
  expect(response.body.error).toContain('email is required')
})

// ‚úÖ Tests que validan edge cases
it('should handle empty arrays gracefully', async () => {
  mockUserService.list.mockResolvedValue([])
  
  const response = await request(app).get('/api/users')
  
  expect(response.status).toBe(200)
  expect(response.body.data).toEqual([])
  expect(response.body.count).toBe(0)
})
```

### üé® TEMPLATES DE TESTS

#### Template para Endpoints REST
```ts
describe('Resource Endpoints', () => {
  // Factories
  const createTestResource = (overrides = {}) => ({
    name: 'Test Resource',
    description: 'Test Description',
    ...overrides
  })

  // Mocks
  const mockResourceService = {
    create: vi.fn(),
    findById: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
    list: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('POST /api/resources', () => {
    it('should create resource with valid data', async () => {
      const validData = createTestResource()
      const mockResponse = { id: 1, ...validData, created_at: new Date() }
      mockResourceService.create.mockResolvedValue(mockResponse)

      const response = await request(app).post('/api/resources').send(validData)

      expect(response.status).toBe(201)
      expect(response.body.success).toBe(true)
      expect(response.body.data).toMatchObject(mockResponse)
      expect(mockResourceService.create).toHaveBeenCalledWith(validData)
    })

    it('should return 400 for invalid data', async () => {
      const invalidData = createTestResource({ name: undefined })

      const response = await request(app).post('/api/resources').send(invalidData)

      expect(response.status).toBe(400)
      expect(response.body.success).toBe(false)
      expect(response.body.error).toBeDefined()
    })
  })

  describe('GET /api/resources/:id', () => {
    it('should return resource by id', async () => {
      const mockResource = createTestResource({ id: 1 })
      mockResourceService.findById.mockResolvedValue(mockResource)

      const response = await request(app).get('/api/resources/1')

      expect(response.status).toBe(200)
      expect(response.body.data).toMatchObject(mockResource)
    })

    it('should return 404 for non-existent resource', async () => {
      mockResourceService.findById.mockResolvedValue(null)

      const response = await request(app).get('/api/resources/999')

      expect(response.status).toBe(404)
    })
  })
})
```

#### Template para Componentes React
```tsx
describe('ComponentName', () => {
  const defaultProps = {
    onSubmit: vi.fn(),
    data: {},
    loading: false
  }

  const renderComponent = (props = {}) => {
    return render(<ComponentName {...defaultProps} {...props} />)
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should render correctly with default props', () => {
    const { getByRole, getByText } = renderComponent()

    expect(getByRole('form')).toBeInTheDocument()
    expect(getByText('Submit')).toBeInTheDocument()
  })

  it('should call onSubmit when form is submitted', async () => {
    const mockOnSubmit = vi.fn()
    const { getByRole } = renderComponent({ onSubmit: mockOnSubmit })

    await userEvent.click(getByRole('button', { name: /submit/i }))

    expect(mockOnSubmit).toHaveBeenCalledTimes(1)
  })

  it('should show loading state', () => {
    const { getByText } = renderComponent({ loading: true })

    expect(getByText('Loading...')).toBeInTheDocument()
  })
})
```

### üîß CONFIGURACI√ìN DE VITEST

#### Backend (apps/backend/vitest.config.ts)
```ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: './vitest.setup.ts',
    // Optimizaciones para tests unitarios r√°pidos
    testTimeout: 5000, // 5 segundos m√°ximo por test
    hookTimeout: 2000, // 2 segundos m√°ximo por hook
    teardownTimeout: 1000, // 1 segundo m√°ximo para cleanup
    // Configuraci√≥n de threads para paralelizaci√≥n
    threads: {
      enabled: true,
      maxThreads: 4,
      minThreads: 2,
    },
    // Configuraci√≥n de coverage optimizada
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'html', 'json', 'json-summary'],
      exclude: [
        '**/node_modules/**',
        '**/dist/**',
        '**/coverage/**',
        '**/*.d.ts',
        '**/vitest.setup.ts',
        '**/vitest.config.ts',
      ],
    },
    // Configuraci√≥n de mocks globales
    mockReset: true,
    restoreMocks: true,
    clearMocks: true,
  },
})
```

#### Frontend (apps/frontend/vitest.config.ts)
```ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './vitest.setup.ts',
    testTimeout: 5000,
    threads: {
      enabled: true,
      maxThreads: 4,
    },
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'html', 'json'],
      exclude: [
        '**/node_modules/**',
        '**/dist/**',
        '**/coverage/**',
        '**/*.d.ts',
      ],
    },
  },
})
```

### üìä COMANDOS DE TESTING

```bash
# Ejecutar todos los tests
pnpm test

# Ejecutar tests con coverage
pnpm test:coverage

# Ejecutar tests espec√≠ficos
pnpm test apps/backend/src/tests/auth.test.ts

# Ejecutar tests en modo watch
pnpm test:watch

# Validar cobertura m√≠nima
pnpm test:coverage:check

# Ejecutar tests de integraci√≥n
pnpm test:integration

# Ejecutar tests E2E
pnpm test:e2e
```

### üéØ INTEGRACI√ìN CON CI/CD

#### GitHub Actions Workflow
```yaml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
      - run: pnpm install
      - run: pnpm test:coverage
      - run: pnpm test:coverage:check
```

### üìà M√âTRICAS DE √âXITO

- **Performance**: 100% de tests <5 segundos
- **Cobertura**: ‚â•90% l√≠neas y branches
- **Fiabilidad**: 100% de tests pasando
- **Mantenibilidad**: Tests legibles y bien estructurados
- **Integraci√≥n**: CI/CD siempre verde

---

## üß™ TESTING

### Backend Tests
- **Unit**: Services y utilidades
- **Integration**: Controllers y router HTTP nativo
- **Mocks**: Supabase, Stripe, OpenAI, PostHog, Resend
- **Coverage**: Vitest con cobertura
- **Framework**: Vitest (`apps/backend/vitest.config.ts`)
- **Rutas de tests**: `apps/backend/src/tests/`
- **Ejemplo de mock:**
  ```ts
  vi.mock('@supabase/supabase-js', () => ({
    createClient: vi.fn(() => ({
      auth: { signInWithPassword: vi.fn() },
      from: vi.fn()
    }))
  }))
  ```

### Frontend Tests
- **Components**: React Testing Library
- **Hooks**: Custom hooks testing
- **API**: MSW para mocking
- **E2E**: Playwright (opcional)
- **Framework**: Vitest (`apps/frontend/vitest.config.ts`)
- **Rutas de tests**: `apps/frontend/src/tests/`, `apps/frontend/tests-e2e/`
- **Ejemplo de mock con MSW:**
  ```ts
  import { rest } from 'msw'
  export const handlers = [
    rest.get('/api/user', (req, res, ctx) => res(ctx.json({ id: 1 })))
  ]
  ```

### Web Tests
- **Playwright**: Para pruebas E2E (`apps/frontend/tests-e2e/`)

## üîê SEGURIDAD

### Authentication
- **Supabase Auth**: JWT tokens
- **Middleware**: authMiddleware para rutas protegidas
- **Rate Limiting**: Implementaci√≥n nativa de limitaci√≥n de peticiones para Node.js puro
- **CORS**: Configurado para producci√≥n
- **Validaci√≥n de tokens**: Siempre validar JWT en endpoints protegidos. Ejemplo:
  ```ts
  if (!req.user) return res.status(401).json({ error: 'No autorizado' })
  ```

### Environment Variables
- **Backend**: SUPABASE_URL, JWT_SECRET, etc.
- **Frontend**: VITE_SUPABASE_URL, etc.
- **Never**: Committear secrets al repo

## üìä MONITORING

### Logging
- **Structured**: Pino con contexto estructurado
- **Levels**: info, warn, error
- **Actions**: Eventos de negocio trackeados
- **logAction()**: Usar para registrar eventos clave de negocio. Ejemplo:
  ```ts
  logAction('user_signup', userId, { email })
  ```

## ü§ñ AGENTES STRATO

### Agentes disponibles
- **@refactor**: Refactorizaci√≥n autom√°tica de c√≥digo. Ubicaci√≥n: `/scripts/agents/refactor/autofix.ts`
- **@qa**: Auditor√≠a de calidad y tests. Ubicaci√≥n: `/scripts/agents/qa/`
- **@data**: Procesamiento y migraci√≥n de datos. Ubicaci√≥n: `/scripts/agents/data/`
- **@merge-strategist**: Estrategias de merge y resoluci√≥n de conflictos. Ubicaci√≥n: `/scripts/agents/merge-strategist/`
- **@context-watchdog**: Monitoreo de contexto y rutas. Ubicaci√≥n: `/scripts/agents/context-watchdog.ts`

### Rol y l√≥gica principal
- Cada agente implementa una funci√≥n principal `runAgent()` y sigue la convenci√≥n de orquestaci√≥n desde `RuntimeService.runAgent()`.
- Los agentes pueden ser invocados desde scripts o CI para tareas autom√°ticas de refactor, QA, migraci√≥n, etc.

## üåê CONEXIONES EXTERNAS
- **Supabase**: Base de datos y autenticaci√≥n principal.
- **Stripe**: Procesamiento de pagos y suscripciones.
- **OpenAI**: Funcionalidades de IA y generaci√≥n de texto.
- **Resend**: Env√≠o de emails transaccionales.
- **PostHog**: Analytics y tracking de eventos.

## üö® ANTI-PATRONES A EVITAR

- ‚ùå Committear secrets
- ‚ùå Any types en TypeScript
- ‚ùå Console.log en producci√≥n
- ‚ùå Mutar props en React
- ‚ùå Callbacks anidados
- ‚ùå Variables globales
- ‚ùå Hardcoded URLs
- ‚ùå Ignorar errores de linting
- ‚ùå Omitir validaci√≥n de tokens en endpoints protegidos
- ‚ùå No usar mocks en tests de integraci√≥n
- ‚ùå No cubrir c√≥digo cr√≠tico con tests
- ‚ùå Depender de servicios externos para startup

## üéØ OBJETIVOS DEL PROYECTO

STRATO es un framework SaaS enterprise-grade que prioriza:
- **Developer Experience**: DX excepcional
- **Code Quality**: C√≥digo limpio y mantenible
- **Security**: Seguridad por defecto
- **Performance**: Rendimiento optimizado
- **Scalability**: Arquitectura escalable
- **Monitoring**: Observabilidad completa

## üìö RECURSOS

- **Supabase Docs**: https://supabase.com/docs
- **Next.js Docs**: https://nextjs.org/docs
- **React Docs**: https://react.dev
- **Tailwind CSS**: https://tailwindcss.com/docs
- **Vitest**: https://vitest.dev

## ‚úÖ CHECKLISTS DE VALIDACI√ìN

### Pull Request Checklist
- [ ] El c√≥digo tiene tests unitarios y de integraci√≥n
- [ ] Se validan tokens en endpoints protegidos
- [ ] Se loguean acciones clave con logAction()
- [ ] No hay secrets ni datos sensibles en el c√≥digo
- [ ] El PR incluye descripci√≥n clara y justificaci√≥n de cambios
- [ ] El c√≥digo sigue las convenciones de naming y estructura
- [ ] Se actualizaron los mocks si cambi√≥ la integraci√≥n externa
- [ ] El build y los tests pasan en CI
- [ ] Los servicios se inicializan de forma modular

### Release Checklist
- [ ] Todos los tests pasan con cobertura m√≠nima
- [ ] No hay dependencias inseguras o deprecated
- [ ] Se revisaron los logs de errores recientes
- [ ] Se actualizaron las migraciones y seeds si aplica
- [ ] Se revisaron los permisos y accesos de servicios externos

---

## üìà COBERTURA M√çNIMA DE TESTS
- **Backend**: 90% l√≠neas, 90% branches
- **Frontend**: 90% l√≠neas, 90% branches
- **Bloquear PRs** si la cobertura baja de ese umbral
- **Comando**: `pnpm test:coverage` y revisar reporte

---

## üö´ EJEMPLOS DE ANTI-PATRONES Y FIXES

### ‚ùå Incorrecto
```ts
// No validar token
app.get('/api/secure', handler)

// Usar any
const data: any = {}

// Console.log en producci√≥n
console.log('debug')

// Mutar props
props.value = 123

// Hardcoded URL
fetch('https://api.stripe.com/v1/charges')
```

### ‚úÖ Correcto
```ts
// Validar token
app.get('/api/secure', authMiddleware, handler)

// Tipado estricto
const data: UserProfile = {}

// Logging estructurado
logger.info({ userId }, 'User logged in')

// Props inmutables
<MyComponent value={value} />

// Usar variables de entorno
fetch(`${process.env.STRIPE_API_URL}/charges`)
```

---

## üîë POL√çTICA DE SECRETS Y VARIABLES

| Variable                | Ubicaci√≥n         | Prop√≥sito                        |
|-------------------------|-------------------|----------------------------------|
| SUPABASE_URL            | Backend, Frontend | URL de Supabase                  |
| SUPABASE_KEY            | Backend           | API Key de Supabase              |
| JWT_SECRET              | Backend           | Firmar y validar JWT             |
| STRIPE_SECRET_KEY       | Backend           | API Key de Stripe                |
| OPENAI_API_KEY          | Backend           | API Key de OpenAI                |
| RESEND_API_KEY          | Backend           | API Key de Resend                |
| POSTHOG_API_KEY         | Backend           | API Key de PostHog               |
| VITE_SUPABASE_URL       | Frontend          | URL de Supabase (public)         |

- **Nunca** committear archivos `.env` ni valores reales
- Usar `.env.example` como plantilla
- Secrets en CI: usar GitHub Actions Secrets o Railway/Vercel envs

---

## üå≥ POL√çTICA DE BRANCHING Y RELEASES
- Solo mergear a `main` v√≠a Pull Request
- CI debe estar en verde y cobertura OK
- Revisi√≥n obligatoria de 2 devs para PRs a main
- Branches:
  - `main`: Producci√≥n
  - `develop`: Integraci√≥n (opcional)
  - `feature/*`: Nuevas features
  - `fix/*`: Hotfixes
  - `chore/*`: Mantenimiento
- Releases: usar tags semver (`v1.2.3`)

---

## üì¶ INTEGRIDAD DE DEPENDENCIAS
- No instalar paquetes sin justificaci√≥n en el PR
- Usar solo versiones estables (`^x.y.z`)
- Revisar dependabot y alertas de seguridad
- Eliminar dependencias no usadas
- Revisar cambios en `pnpm-lock.yaml` en cada PR

---

## üõ°Ô∏è REVISI√ìN DE ACCESOS Y PERMISOS
- Revisar roles y permisos en Supabase peri√≥dicamente
- Rotar claves de API cada 90 d√≠as
- Revisar accesos a Stripe, OpenAI, Resend y PostHog
- Limitar permisos de servicio a lo m√≠nimo necesario
- Documentar cambios de permisos en el PR

---

## üïµÔ∏è AUDITOR√çA Y OBSERVABILIDAD
- Auditar logs cr√≠ticos semanalmente
- Revisar errores y alertas en PostHog y logs de Pino
- Consultar m√©tricas de performance y uso
- Ejemplo de consulta de logs:
  ```sh
  pnpm logs | grep error
  ```
- Documentar incidentes y acciones correctivas

---

## ü§ñ AUTOMATIZACI√ìN Y SCRIPTS CLAVE
- `pnpm lint` ‚Äî Linting de todo el monorepo
- `pnpm test` ‚Äî Ejecutar todos los tests
- `pnpm build` ‚Äî Build de producci√≥n
- `pnpm format` ‚Äî Formato autom√°tico
- `pnpm check-react-imports` ‚Äî Verifica imports de React
- `pnpm tsx scripts/agents/refactor/autofix.ts` ‚Äî Refactor autom√°tico
- `pnpm tsx scripts/agents/qa/` ‚Äî Auditor√≠a de calidad
- `pnpm tsx scripts/agents/context-watchdog.ts` ‚Äî Monitoreo de contexto

---

## üöÄ ONBOARDING EXPRESS PARA NUEVOS DEVS
1. Clona el repo y corre `pnpm install`
2. Copia `.env.example` a `.env` y configura tus variables
3. Corre `pnpm dev` para levantar backend y frontend
4. Corre `pnpm test` para validar que todo pase
5. Lee `.cursorrules` y sigue los patrones
6. Haz tu feature en una branch `feature/tu-feature`
7. Abre un PR con checklist y justificaci√≥n
8. Pide revisi√≥n a 2 devs y espera CI verde
9. ¬°Bienvenido a STRATO! üöÄ 

## üìè REGLAS DE FORMATO, LINT Y CALIDAD (STRATO)

> **Estas reglas son de cumplimiento obligatorio para todo el c√≥digo, tests y documentaci√≥n en STRATO.**

```json
{
  "rules": [
    {
      "description": "Formato de c√≥digo y estilo (Prettier y ESLint STRATO)",
      "enforced": true,
      "details": [
        "Indentaci√≥n: 2 espacios.",
        "Comillas: simples ('), sin excepciones.",
        "Punto y coma: nunca.",
        "Arrow functions: usar siempre que sea posible.",
        "Preferir `const` y `let`, nunca `var`.",
        "Imports: ordenados, sin duplicados, usar alias (@) si est√° configurado.",
        "Evitar `console.log` en producci√≥n: usar logger del sistema STRATO.",
        "No usar `any`, excepto en firmas de mocks con justificaci√≥n.",
        "No dejar c√≥digo comentado muerto.",
        "No generar funciones an√≥nimas dentro de useEffect sin cleanup."
      ]
    },
    {
      "description": "Husky y pre-commit (simular validaciones en tiempo real)",
      "enforced": true,
      "details": [
        "Validar ESLint antes de finalizar c√≥digo.",
        "Formatear con Prettier en tiempo real (como si el hook ya hubiera actuado).",
        "No generar c√≥digo que requiera `--no-verify` para commitear.",
        "No dejar archivos con cambios innecesarios en `staged` (como logs, .env, test.mocks.ts)."
      ]
    },
    {
      "description": "Manejo estricto de tipos en TypeScript",
      "enforced": true,
      "details": [
        "Todos los props, inputs, outputs y funciones deben estar tipados.",
        "Nunca usar `any` global, `unknown` preferible si no se puede determinar.",
        "En tests, los mocks deben usar `MockInstance<ReturnType, Args>` expl√≠cito.",
        "Evitar uso de `as unknown as X` salvo en casos documentados.",
        "Evitar `// @ts-ignore`, usarlo solo si hay justificaci√≥n clara en comentario."
      ]
    },
    {
      "description": "Pruebas (tests unitarios, integraci√≥n, mocks)",
      "enforced": true,
      "details": [
        "Usar Vitest y los helpers del sistema STRATO.",
        "No generar asserts triviales o sin valor (como `expect(true).toBe(true)`).",
        "Mocks deben tener retorno v√°lido y tipo correcto (`MockInstance`).",
        "No dejar tests con `skip`, `todo` o `only` al finalizar.",
        "Tests deben cubrir flujos positivos y negativos."
      ]
    },
    {
      "description": "Naming y estructura STRATO",
      "enforced": true,
      "details": [
        "Los servicios terminan en `.service.ts`, controladores en `.controller.ts`, rutas en `.routes.ts`.",
        "Los tests terminan en `.test.ts` o `.test.tsx` seg√∫n corresponda.",
        "Las factories terminan en `.factory.ts` y se colocan en `__tests__/`.",
        "Ning√∫n archivo debe exceder 300 l√≠neas sin justificaci√≥n."
      ]
    }
  ]
}
```

> **Nota:** Cualquier PR que no cumpla estas reglas ser√° bloqueado por CI/pre-commit y deber√° ser corregido antes de mergear.

---

Act√∫a como un agente AI de desarrollo que trabaja dentro de un entorno compartido con otros editores (VS Code, Cursor, Windsor), cada uno operando en proyectos distintos y ubicados en carpetas independientes dentro del mismo equipo local.

BAJO NINGUNA CIRCUNSTANCIA debes ejecutar acciones que afecten al entorno global del sistema operativo ni a otros proyectos en paralelo.

OBLIGATORIO:

1. Trabaja exclusivamente dentro de la carpeta del proyecto abierto. No salgas fuera de este directorio bajo ninguna raz√≥n.
2. No instales paquetes globales. Evita cualquier uso de `npm install -g`, `pnpm add -g`, `yarn global add`, etc.
3. Si necesitas herramientas como `eslint`, `vitest`, `tsc`, `tsx`, `prettier`, inst√°lalas √∫nicamente como dependencias locales con `--save-dev`.
4. Usa siempre los scripts definidos en el `package.json` del proyecto actual (`pnpm run lint`, `pnpm run test`, etc.). No uses comandos globales por consola.
5. No cambies configuraciones globales del sistema (`~/.bashrc`, `~/.zshrc`, `~/.npmrc`, `~/.gitconfig`).
6. No edites ni accedas archivos fuera del proyecto actual (aunque est√©n en carpetas hermanas).
7. Si necesitas instalar Node.js, verifica si hay un archivo `.nvmrc`. Si existe, √∫salo. Si no, solicita confirmaci√≥n antes de modificar versi√≥n.
8. No modifiques variables de entorno globales ni comunes. Usa `.env` local, nunca `.env.global`, `.bash_profile`, ni `export` directo.
9. Si detectas conflictos de puertos, servicios duplicados o bases de datos compartidas, **detente** y lanza advertencia. No sobreescribas configuraciones.
10. Toda configuraci√≥n, instalaci√≥n o cambio debe permanecer autocontenida en el directorio del proyecto activo.

Finalidad: proteger la integridad del entorno compartido, evitar conflictos entre editores y mantener una operaci√≥n paralela segura de m√∫ltiples repos en la misma m√°quina.

Si no entiendes una instrucci√≥n o tienes dudas, solicita aclaraci√≥n en lugar de asumir.