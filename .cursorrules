# STRATO Core OSâ„¢ - Cursor Rules

## ğŸ—ï¸ ARQUITECTURA DEL PROYECTO

STRATO es un monorepo SaaS con arquitectura modular:

```
matriz_cursor/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ backend/          # API Node.js/Express + Supabase
â”‚   â”œâ”€â”€ frontend/         # React + Vite + TypeScript
â”‚   â””â”€â”€ web/             # Next.js Landing + Control Tower
â”œâ”€â”€ packages/             # LibrerÃ­as compartidas
â”œâ”€â”€ supabase/            # Base de datos y migraciones
â””â”€â”€ scripts/             # Herramientas de desarrollo
```

## ğŸ¯ PATRONES Y CONVENCIONES

### Backend (Node.js/Express)
- **Controllers**: Manejan requests/responses, validaciÃ³n, logging
- **Services**: LÃ³gica de negocio, integraciÃ³n con APIs externas
- **Routes**: DefiniciÃ³n de endpoints REST
- **Middleware**: Auth, rate limiting, error handling, logging
- **Types**: Tipos TypeScript para Supabase y Express

### Frontend (React/Vite)
- **Components**: Reutilizables en `/components/ui/`
- **Pages**: PÃ¡ginas principales en `/app/`
- **Services**: APIs y servicios externos
- **Contexts**: Estado global (AuthContext)
- **Hooks**: LÃ³gica reutilizable

### Web (Next.js)
- **App Router**: Estructura moderna de Next.js 15
- **API Routes**: Endpoints para auditorÃ­a y control
- **Components**: Landing page y Control Tower

## ğŸ”§ TECNOLOGÃAS PRINCIPALES

### Backend
- **Node.js + Express 5**: API REST
- **TypeScript**: Tipado estÃ¡tico
- **Supabase**: Base de datos PostgreSQL + Auth
- **Stripe**: Pagos
- **OpenAI**: IA
- **PostHog**: Analytics
- **Resend**: Email
- **Pino**: Logging estructurado

### Frontend
- **React 18**: UI Framework
- **Vite**: Build tool
- **TypeScript**: Tipado estÃ¡tico
- **Tailwind CSS**: Estilos
- **Vitest**: Testing
- **MSW**: Mock Service Worker

### Web
- **Next.js 15**: Framework React
- **App Router**: Enrutamiento moderno
- **TypeScript**: Tipado estÃ¡tico

## ğŸ“ CONVENCIONES DE CÃ“DIGO

### Naming
- **Files**: kebab-case (auth.controller.ts)
- **Functions**: camelCase (getUserProfile)
- **Classes**: PascalCase (AuthService)
- **Constants**: UPPER_SNAKE_CASE (API_BASE_URL)
- **Types**: PascalCase (UserProfile)

### Imports
- **Relative**: Para archivos del mismo mÃ³dulo
- **Absolute**: Para paquetes externos
- **Workspace**: Para paquetes internos (@repo/db-types)

### Error Handling
- **Controllers**: Try/catch con next(error)
- **Services**: Throw ApiError con cÃ³digos HTTP
- **Frontend**: Error boundaries y estados de error

### Logging
- **Structured**: Pino con contexto estructurado
- **Actions**: logAction() para eventos de negocio
- **Levels**: info, warn, error segÃºn severidad

## ğŸ§ª TESTING STANDARDS - ESTRATEGIA GLOBAL

### ğŸ¯ OBJETIVOS PRINCIPALES
Los tests en STRATO deben:
1. **Ser realistas** - Reflejar la lÃ³gica de negocio esperada
2. **Pasar desde el primer intento** - Sin debugging innecesario
3. **Ser unitarios puros** - Sin dependencias externas (Supabase, Stripe, OpenAI, etc.)
4. **Usar mocks apropiados** - `vi.mock()` o `msw` para evitar IO real
5. **Ser ultra-rÃ¡pidos** - Idealmente <5 segundos por suite
6. **Manejar errores explÃ­citamente** - ZodError debe devolver 400, no 500
7. **Validar inputs numÃ©ricos** - `limit`, `offset`, `user_id`, etc.
8. **Cubrir flujos positivos y negativos** - Sin repetir lÃ³gica
9. **Tener estructura clara** - `describe/it` bien organizado
10. **Cumplir reglas de calidad** - `.cursorrules` y `eslint`

### ğŸ“Š MÃ‰TRICAS DE CALIDAD
- **Performance**: <5 segundos por suite de tests
- **Cobertura**: â‰¥90% lÃ­neas y branches
- **Fiabilidad**: 100% de tests pasando consistentemente
- **Mantenibilidad**: Tests legibles y bien estructurados

### ğŸ—ï¸ ARQUITECTURA DE TESTS

#### Backend Tests (Vitest + Supertest)
```ts
// Estructura recomendada
describe('POST /api/campaigns', () => {
  // Factories para datos consistentes
  const createTestCampaign = (overrides = {}) => ({
    title: 'Test Campaign',
    description: 'Test Description',
    budget: 1000,
    ...overrides
  })

  // Mocks globales
  const mockCampaignService = {
    create: vi.fn(),
    update: vi.fn(),
    delete: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
    // Configurar mocks especÃ­ficos
  })

  it('should create campaign with valid data', async () => {
    // Arrange
    const validData = createTestCampaign()
    const mockResponse = { id: 1, ...validData, created_at: new Date() }
    mockCampaignService.create.mockResolvedValue(mockResponse)

    // Act
    const startTime = Date.now()
    const response = await request(app)
      .post('/api/campaigns')
      .send(validData)
    const duration = Date.now() - startTime

    // Assert
    expect(duration).toBeLessThan(5000) // Performance check
    expect(response.status).toBe(201)
    expect(response.body).toMatchObject({
      success: true,
      data: expect.objectContaining({
        id: expect.any(Number),
        title: validData.title,
        budget: validData.budget
      })
    })
    expect(mockCampaignService.create).toHaveBeenCalledTimes(1)
    expect(mockCampaignService.create).toHaveBeenCalledWith(validData)
  })

  it('should return 400 for missing title', async () => {
    // Arrange
    const invalidData = createTestCampaign({ title: undefined })

    // Act
    const response = await request(app)
      .post('/api/campaigns')
      .send(invalidData)

    // Assert
    expect(response.status).toBe(400)
    expect(response.body.success).toBe(false)
    expect(response.body.error).toBeDefined()
  })

  it('should handle malformed JSON gracefully', async () => {
    // Act
    const response = await request(app)
      .post('/api/campaigns')
      .set('Content-Type', 'application/json')
      .send('{"invalid": json}')

    // Assert
    expect(response.status).toBe(400)
  })
})
```

#### Frontend Tests (Vitest + React Testing Library)
```tsx
// Estructura recomendada para componentes
describe('CampaignForm Component', () => {
  const renderCampaignForm = (props = {}) => {
    return render(
      <CampaignForm 
        onSubmit={vi.fn()}
        initialData={{}}
        {...props}
      />
    )
  }

  it('should render form fields correctly', () => {
    // Arrange & Act
    const { getByLabelText, getByRole } = renderCampaignForm()

    // Assert
    expect(getByLabelText(/title/i)).toBeInTheDocument()
    expect(getByLabelText(/budget/i)).toBeInTheDocument()
    expect(getByRole('button', { name: /submit/i })).toBeInTheDocument()
  })

  it('should call onSubmit with form data', async () => {
    // Arrange
    const mockOnSubmit = vi.fn()
    const { getByLabelText, getByRole } = renderCampaignForm({ onSubmit: mockOnSubmit })

    // Act
    await userEvent.type(getByLabelText(/title/i), 'Test Campaign')
    await userEvent.type(getByLabelText(/budget/i), '1000')
    await userEvent.click(getByRole('button', { name: /submit/i }))

    // Assert
    expect(mockOnSubmit).toHaveBeenCalledWith({
      title: 'Test Campaign',
      budget: 1000
    })
  })
})
```

### ğŸ”§ MOCKING STRATEGY

#### Backend Mocks (Vitest)
```ts
// Mock de servicios externos
vi.mock('../services/supabase.service.js', () => ({
  supabase: {
    from: vi.fn(() => ({
      insert: vi.fn(() => ({
        select: vi.fn(() => Promise.resolve({ 
          data: [{ id: 1, name: 'test' }], 
          error: null 
        }))
      })),
      select: vi.fn(() => ({
        order: vi.fn(() => ({
          limit: vi.fn(() => ({
            range: vi.fn(() => Promise.resolve({ data: [], error: null }))
          }))
        }))
      }))
    }))
  }
}))

// Mock de middleware
vi.mock('../middleware/auth.middleware.js', () => ({
  authMiddleware: vi.fn((req, res, next) => {
    req.user = { id: 1, email: 'test@example.com' }
    next()
  })
}))

// Mock de servicios de terceros
vi.mock('stripe', () => ({
  default: vi.fn(() => ({
    paymentIntents: {
      create: vi.fn(() => Promise.resolve({ id: 'pi_test' }))
    }
  }))
}))
```

#### Frontend Mocks (MSW)
```ts
// handlers.ts
import { rest } from 'msw'

export const handlers = [
  rest.post('/api/campaigns', (req, res, ctx) => {
    return res(
      ctx.status(201),
      ctx.json({
        success: true,
        data: {
          id: 1,
          title: 'Test Campaign',
          created_at: new Date().toISOString()
        }
      })
    )
  }),

  rest.get('/api/campaigns', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        success: true,
        data: [
          { id: 1, title: 'Campaign 1' },
          { id: 2, title: 'Campaign 2' }
        ]
      })
    )
  })
]
```

### ğŸ“‹ CHECKLIST DE VALIDACIÃ“N DE TESTS

#### Antes de crear tests:
- [ ] Â¿El test refleja un caso de uso real?
- [ ] Â¿EstÃ¡n mockeados todos los servicios externos?
- [ ] Â¿Se validan tanto casos positivos como negativos?
- [ ] Â¿Se manejan errores de validaciÃ³n (ZodError â†’ 400)?
- [ ] Â¿Se validan inputs numÃ©ricos correctamente?
- [ ] Â¿El test es independiente y no afecta otros tests?

#### Durante la implementaciÃ³n:
- [ ] Â¿Se usan factories para datos consistentes?
- [ ] Â¿Se mide el tiempo de ejecuciÃ³n (<5s)?
- [ ] Â¿Se validan las llamadas a mocks?
- [ ] Â¿Se verifica la estructura completa de respuesta?
- [ ] Â¿Se incluyen edge cases importantes?

#### DespuÃ©s de implementar:
- [ ] Â¿Todos los tests pasan consistentemente?
- [ ] Â¿La cobertura es â‰¥90%?
- [ ] Â¿Los tests son legibles y mantenibles?
- [ ] Â¿Se documentan casos especiales?
- [ ] Â¿Se integran con CI/CD?

### ğŸš« ANTI-PATRONES DE TESTING

#### âŒ NO HACER
```ts
// âŒ Tests que dependen de servicios externos
it('should create user in database', async () => {
  const user = await createUserInRealDatabase() // MALO
})

// âŒ Tests lentos (>5 segundos)
it('should process large dataset', async () => {
  await processLargeDataset() // MALO - muy lento
})

// âŒ Tests que no validan estructura
it('should return success', async () => {
  const response = await request(app).post('/api/users')
  expect(response.status).toBe(200) // MALO - muy bÃ¡sico
})

// âŒ Tests que no manejan errores
it('should handle invalid data', async () => {
  const response = await request(app).post('/api/users').send({})
  // No valida el error especÃ­fico - MALO
})

// âŒ Mocks incompletos
vi.mock('supabase', () => ({
  // Mock incompleto que causa errores - MALO
}))
```

#### âœ… HACER
```ts
// âœ… Tests con mocks apropiados
it('should create user successfully', async () => {
  const mockUser = { id: 1, email: 'test@example.com' }
  mockUserService.create.mockResolvedValue(mockUser)
  
  const response = await request(app).post('/api/users').send(validUserData)
  
  expect(response.status).toBe(201)
  expect(response.body.data).toMatchObject(mockUser)
  expect(mockUserService.create).toHaveBeenCalledWith(validUserData)
})

// âœ… Tests rÃ¡pidos con validaciÃ³n completa
it('should validate user data', async () => {
  const startTime = Date.now()
  
  const response = await request(app).post('/api/users').send(invalidData)
  
  const duration = Date.now() - startTime
  expect(duration).toBeLessThan(1000) // <1s
  expect(response.status).toBe(400)
  expect(response.body.error).toContain('email is required')
})

// âœ… Tests que validan edge cases
it('should handle empty arrays gracefully', async () => {
  mockUserService.list.mockResolvedValue([])
  
  const response = await request(app).get('/api/users')
  
  expect(response.status).toBe(200)
  expect(response.body.data).toEqual([])
  expect(response.body.count).toBe(0)
})
```

### ğŸ¨ TEMPLATES DE TESTS

#### Template para Endpoints REST
```ts
describe('Resource Endpoints', () => {
  // Factories
  const createTestResource = (overrides = {}) => ({
    name: 'Test Resource',
    description: 'Test Description',
    ...overrides
  })

  // Mocks
  const mockResourceService = {
    create: vi.fn(),
    findById: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
    list: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('POST /api/resources', () => {
    it('should create resource with valid data', async () => {
      const validData = createTestResource()
      const mockResponse = { id: 1, ...validData, created_at: new Date() }
      mockResourceService.create.mockResolvedValue(mockResponse)

      const response = await request(app).post('/api/resources').send(validData)

      expect(response.status).toBe(201)
      expect(response.body.success).toBe(true)
      expect(response.body.data).toMatchObject(mockResponse)
      expect(mockResourceService.create).toHaveBeenCalledWith(validData)
    })

    it('should return 400 for invalid data', async () => {
      const invalidData = createTestResource({ name: undefined })

      const response = await request(app).post('/api/resources').send(invalidData)

      expect(response.status).toBe(400)
      expect(response.body.success).toBe(false)
      expect(response.body.error).toBeDefined()
    })
  })

  describe('GET /api/resources/:id', () => {
    it('should return resource by id', async () => {
      const mockResource = createTestResource({ id: 1 })
      mockResourceService.findById.mockResolvedValue(mockResource)

      const response = await request(app).get('/api/resources/1')

      expect(response.status).toBe(200)
      expect(response.body.data).toMatchObject(mockResource)
    })

    it('should return 404 for non-existent resource', async () => {
      mockResourceService.findById.mockResolvedValue(null)

      const response = await request(app).get('/api/resources/999')

      expect(response.status).toBe(404)
    })
  })
})
```

#### Template para Componentes React
```tsx
describe('ComponentName', () => {
  const defaultProps = {
    onSubmit: vi.fn(),
    data: {},
    loading: false
  }

  const renderComponent = (props = {}) => {
    return render(<ComponentName {...defaultProps} {...props} />)
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should render correctly with default props', () => {
    const { getByRole, getByText } = renderComponent()

    expect(getByRole('form')).toBeInTheDocument()
    expect(getByText('Submit')).toBeInTheDocument()
  })

  it('should call onSubmit when form is submitted', async () => {
    const mockOnSubmit = vi.fn()
    const { getByRole } = renderComponent({ onSubmit: mockOnSubmit })

    await userEvent.click(getByRole('button', { name: /submit/i }))

    expect(mockOnSubmit).toHaveBeenCalledTimes(1)
  })

  it('should show loading state', () => {
    const { getByText } = renderComponent({ loading: true })

    expect(getByText('Loading...')).toBeInTheDocument()
  })
})
```

### ğŸ”§ CONFIGURACIÃ“N DE VITEST

#### Backend (apps/backend/vitest.config.ts)
```ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: './vitest.setup.ts',
    // Optimizaciones para tests unitarios rÃ¡pidos
    testTimeout: 5000, // 5 segundos mÃ¡ximo por test
    hookTimeout: 2000, // 2 segundos mÃ¡ximo por hook
    teardownTimeout: 1000, // 1 segundo mÃ¡ximo para cleanup
    // ConfiguraciÃ³n de threads para paralelizaciÃ³n
    threads: {
      enabled: true,
      maxThreads: 4,
      minThreads: 2,
    },
    // ConfiguraciÃ³n de coverage optimizada
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'html', 'json', 'json-summary'],
      exclude: [
        '**/node_modules/**',
        '**/dist/**',
        '**/coverage/**',
        '**/*.d.ts',
        '**/vitest.setup.ts',
        '**/vitest.config.ts',
      ],
    },
    // ConfiguraciÃ³n de mocks globales
    mockReset: true,
    restoreMocks: true,
    clearMocks: true,
  },
})
```

#### Frontend (apps/frontend/vitest.config.ts)
```ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './vitest.setup.ts',
    testTimeout: 5000,
    threads: {
      enabled: true,
      maxThreads: 4,
    },
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'html', 'json'],
      exclude: [
        '**/node_modules/**',
        '**/dist/**',
        '**/coverage/**',
        '**/*.d.ts',
      ],
    },
  },
})
```

### ğŸ“Š COMANDOS DE TESTING

```bash
# Ejecutar todos los tests
pnpm test

# Ejecutar tests con coverage
pnpm test:coverage

# Ejecutar tests especÃ­ficos
pnpm test apps/backend/src/tests/auth.test.ts

# Ejecutar tests en modo watch
pnpm test:watch

# Validar cobertura mÃ­nima
pnpm test:coverage:check

# Ejecutar tests de integraciÃ³n
pnpm test:integration

# Ejecutar tests E2E
pnpm test:e2e
```

### ğŸ¯ INTEGRACIÃ“N CON CI/CD

#### GitHub Actions Workflow
```yaml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
      - run: pnpm install
      - run: pnpm test:coverage
      - run: pnpm test:coverage:check
```

### ğŸ“ˆ MÃ‰TRICAS DE Ã‰XITO

- **Performance**: 100% de tests <5 segundos
- **Cobertura**: â‰¥90% lÃ­neas y branches
- **Fiabilidad**: 100% de tests pasando
- **Mantenibilidad**: Tests legibles y bien estructurados
- **IntegraciÃ³n**: CI/CD siempre verde

---

## ğŸ§ª TESTING

### Backend Tests
- **Unit**: Services y utilidades
- **Integration**: Controllers y routes
- **Mocks**: Supabase, Stripe, OpenAI, PostHog, Resend
- **Coverage**: Vitest con cobertura
- **Framework**: Vitest (`apps/backend/vitest.config.ts`)
- **Rutas de tests**: `apps/backend/src/tests/`
- **Ejemplo de mock:**
  ```ts
  vi.mock('@supabase/supabase-js', () => ({
    createClient: vi.fn(() => ({
      auth: { signInWithPassword: vi.fn() },
      from: vi.fn()
    }))
  }))
  ```

### Frontend Tests
- **Components**: React Testing Library
- **Hooks**: Custom hooks testing
- **API**: MSW para mocking
- **E2E**: Playwright (opcional)
- **Framework**: Vitest (`apps/frontend/vitest.config.ts`)
- **Rutas de tests**: `apps/frontend/src/tests/`, `apps/frontend/tests-e2e/`
- **Ejemplo de mock con MSW:**
  ```ts
  import { rest } from 'msw'
  export const handlers = [
    rest.get('/api/user', (req, res, ctx) => res(ctx.json({ id: 1 })))
  ]
  ```

### Web Tests
- **Playwright**: Para pruebas E2E (`apps/frontend/tests-e2e/`)

## ğŸ” SEGURIDAD

### Authentication
- **Supabase Auth**: JWT tokens
- **Middleware**: authMiddleware para rutas protegidas
- **Rate Limiting**: express-rate-limit
- **CORS**: Configurado para producciÃ³n
- **ValidaciÃ³n de tokens**: Siempre validar JWT en endpoints protegidos. Ejemplo:
  ```ts
  if (!req.user) return res.status(401).json({ error: 'No autorizado' })
  ```

### Environment Variables
- **Backend**: SUPABASE_URL, JWT_SECRET, etc.
- **Frontend**: VITE_SUPABASE_URL, etc.
- **Never**: Committear secrets al repo

## ğŸ“Š MONITORING

### Logging
- **Structured**: Pino con contexto estructurado
- **Levels**: info, warn, error
- **Actions**: Eventos de negocio trackeados
- **logAction()**: Usar para registrar eventos clave de negocio. Ejemplo:
  ```ts
  logAction('user_signup', userId, { email })
  ```

## ğŸ¤– AGENTES STRATO

### Agentes disponibles
- **@refactor**: RefactorizaciÃ³n automÃ¡tica de cÃ³digo. UbicaciÃ³n: `/scripts/agents/refactor/autofix.ts`
- **@qa**: AuditorÃ­a de calidad y tests. UbicaciÃ³n: `/scripts/agents/qa/`
- **@data**: Procesamiento y migraciÃ³n de datos. UbicaciÃ³n: `/scripts/agents/data/`
- **@merge-strategist**: Estrategias de merge y resoluciÃ³n de conflictos. UbicaciÃ³n: `/scripts/agents/merge-strategist/`
- **@context-watchdog**: Monitoreo de contexto y rutas. UbicaciÃ³n: `/scripts/agents/context-watchdog.ts`

### Rol y lÃ³gica principal
- Cada agente implementa una funciÃ³n principal `runAgent()` y sigue la convenciÃ³n de orquestaciÃ³n desde `RuntimeService.runAgent()`.
- Los agentes pueden ser invocados desde scripts o CI para tareas automÃ¡ticas de refactor, QA, migraciÃ³n, etc.

## ğŸŒ CONEXIONES EXTERNAS
- **Supabase**: Base de datos y autenticaciÃ³n principal.
- **Stripe**: Procesamiento de pagos y suscripciones.
- **OpenAI**: Funcionalidades de IA y generaciÃ³n de texto.
- **Resend**: EnvÃ­o de emails transaccionales.
- **PostHog**: Analytics y tracking de eventos.

## ğŸš¨ ANTI-PATRONES A EVITAR

- âŒ Committear secrets
- âŒ Any types en TypeScript
- âŒ Console.log en producciÃ³n
- âŒ Mutar props en React
- âŒ Callbacks anidados
- âŒ Variables globales
- âŒ Hardcoded URLs
- âŒ Ignorar errores de linting
- âŒ Omitir validaciÃ³n de tokens en endpoints protegidos
- âŒ No usar mocks en tests de integraciÃ³n
- âŒ No cubrir cÃ³digo crÃ­tico con tests

## ğŸ¯ OBJETIVOS DEL PROYECTO

STRATO es un framework SaaS enterprise-grade que prioriza:
- **Developer Experience**: DX excepcional
- **Code Quality**: CÃ³digo limpio y mantenible
- **Security**: Seguridad por defecto
- **Performance**: Rendimiento optimizado
- **Scalability**: Arquitectura escalable
- **Monitoring**: Observabilidad completa

## ğŸ“š RECURSOS

- **Supabase Docs**: https://supabase.com/docs
- **Next.js Docs**: https://nextjs.org/docs
- **React Docs**: https://react.dev
- **Tailwind CSS**: https://tailwindcss.com/docs
- **Vitest**: https://vitest.dev

## âœ… CHECKLISTS DE VALIDACIÃ“N

### Pull Request Checklist
- [ ] El cÃ³digo tiene tests unitarios y de integraciÃ³n
- [ ] Se validan tokens en endpoints protegidos
- [ ] Se loguean acciones clave con logAction()
- [ ] No hay secrets ni datos sensibles en el cÃ³digo
- [ ] El PR incluye descripciÃ³n clara y justificaciÃ³n de cambios
- [ ] El cÃ³digo sigue las convenciones de naming y estructura
- [ ] Se actualizaron los mocks si cambiÃ³ la integraciÃ³n externa
- [ ] El build y los tests pasan en CI

### Release Checklist
- [ ] Todos los tests pasan con cobertura mÃ­nima
- [ ] No hay dependencias inseguras o deprecated
- [ ] Se revisaron los logs de errores recientes
- [ ] Se actualizaron las migraciones y seeds si aplica
- [ ] Se revisaron los permisos y accesos de servicios externos

---

## ğŸ“ˆ COBERTURA MÃNIMA DE TESTS
- **Backend**: 90% lÃ­neas, 90% branches
- **Frontend**: 90% lÃ­neas, 90% branches
- **Bloquear PRs** si la cobertura baja de ese umbral
- **Comando**: `pnpm test:coverage` y revisar reporte

---

## ğŸš« EJEMPLOS DE ANTI-PATRONES Y FIXES

### âŒ Incorrecto
```ts
// No validar token
app.get('/api/secure', handler)

// Usar any
const data: any = {}

// Console.log en producciÃ³n
console.log('debug')

// Mutar props
props.value = 123

// Hardcoded URL
fetch('https://api.stripe.com/v1/charges')
```

### âœ… Correcto
```ts
// Validar token
app.get('/api/secure', authMiddleware, handler)

// Tipado estricto
const data: UserProfile = {}

// Logging estructurado
logger.info({ userId }, 'User logged in')

// Props inmutables
<MyComponent value={value} />

// Usar variables de entorno
fetch(`${process.env.STRIPE_API_URL}/charges`)
```

---

## ğŸ”‘ POLÃTICA DE SECRETS Y VARIABLES

| Variable                | UbicaciÃ³n         | PropÃ³sito                        |
|-------------------------|-------------------|----------------------------------|
| SUPABASE_URL            | Backend, Frontend | URL de Supabase                  |
| SUPABASE_KEY            | Backend           | API Key de Supabase              |
| JWT_SECRET              | Backend           | Firmar y validar JWT             |
| STRIPE_SECRET_KEY       | Backend           | API Key de Stripe                |
| OPENAI_API_KEY          | Backend           | API Key de OpenAI                |
| RESEND_API_KEY          | Backend           | API Key de Resend                |
| POSTHOG_API_KEY         | Backend           | API Key de PostHog               |
| VITE_SUPABASE_URL       | Frontend          | URL de Supabase (public)         |

- **Nunca** committear archivos `.env` ni valores reales
- Usar `.env.example` como plantilla
- Secrets en CI: usar GitHub Actions Secrets o Railway/Vercel envs

---

## ğŸŒ³ POLÃTICA DE BRANCHING Y RELEASES
- Solo mergear a `main` vÃ­a Pull Request
- CI debe estar en verde y cobertura OK
- RevisiÃ³n obligatoria de 2 devs para PRs a main
- Branches:
  - `main`: ProducciÃ³n
  - `develop`: IntegraciÃ³n (opcional)
  - `feature/*`: Nuevas features
  - `fix/*`: Hotfixes
  - `chore/*`: Mantenimiento
- Releases: usar tags semver (`v1.2.3`)

---

## ğŸ“¦ INTEGRIDAD DE DEPENDENCIAS
- No instalar paquetes sin justificaciÃ³n en el PR
- Usar solo versiones estables (`^x.y.z`)
- Revisar dependabot y alertas de seguridad
- Eliminar dependencias no usadas
- Revisar cambios en `pnpm-lock.yaml` en cada PR

---

## ğŸ›¡ï¸ REVISIÃ“N DE ACCESOS Y PERMISOS
- Revisar roles y permisos en Supabase periÃ³dicamente
- Rotar claves de API cada 90 dÃ­as
- Revisar accesos a Stripe, OpenAI, Resend y PostHog
- Limitar permisos de servicio a lo mÃ­nimo necesario
- Documentar cambios de permisos en el PR

---

## ğŸ•µï¸ AUDITORÃA Y OBSERVABILIDAD
- Auditar logs crÃ­ticos semanalmente
- Revisar errores y alertas en PostHog y logs de Pino
- Consultar mÃ©tricas de performance y uso
- Ejemplo de consulta de logs:
  ```sh
  pnpm logs | grep error
  ```
- Documentar incidentes y acciones correctivas

---

## ğŸ¤– AUTOMATIZACIÃ“N Y SCRIPTS CLAVE
- `pnpm lint` â€” Linting de todo el monorepo
- `pnpm test` â€” Ejecutar todos los tests
- `pnpm build` â€” Build de producciÃ³n
- `pnpm format` â€” Formato automÃ¡tico
- `pnpm check-react-imports` â€” Verifica imports de React
- `pnpm tsx scripts/agents/refactor/autofix.ts` â€” Refactor automÃ¡tico
- `pnpm tsx scripts/agents/qa/` â€” AuditorÃ­a de calidad
- `pnpm tsx scripts/agents/context-watchdog.ts` â€” Monitoreo de contexto

---

## ğŸš€ ONBOARDING EXPRESS PARA NUEVOS DEVS
1. Clona el repo y corre `pnpm install`
2. Copia `.env.example` a `.env` y configura tus variables
3. Corre `pnpm dev` para levantar backend y frontend
4. Corre `pnpm test` para validar que todo pase
5. Lee `.cursorrules` y sigue los patrones
6. Haz tu feature en una branch `feature/tu-feature`
7. Abre un PR con checklist y justificaciÃ³n
8. Pide revisiÃ³n a 2 devs y espera CI verde
9. Â¡Bienvenido a STRATO! ğŸš€ 

## ğŸ“ REGLAS DE FORMATO, LINT Y CALIDAD (STRATO)

> **Estas reglas son de cumplimiento obligatorio para todo el cÃ³digo, tests y documentaciÃ³n en STRATO.**

```json
{
  "rules": [
    {
      "description": "Formato de cÃ³digo y estilo (Prettier y ESLint STRATO)",
      "enforced": true,
      "details": [
        "IndentaciÃ³n: 2 espacios.",
        "Comillas: simples ('), sin excepciones.",
        "Punto y coma: nunca.",
        "Arrow functions: usar siempre que sea posible.",
        "Preferir `const` y `let`, nunca `var`.",
        "Imports: ordenados, sin duplicados, usar alias (@) si estÃ¡ configurado.",
        "Evitar `console.log` en producciÃ³n: usar logger del sistema STRATO.",
        "No usar `any`, excepto en firmas de mocks con justificaciÃ³n.",
        "No dejar cÃ³digo comentado muerto.",
        "No generar funciones anÃ³nimas dentro de useEffect sin cleanup."
      ]
    },
    {
      "description": "Husky y pre-commit (simular validaciones en tiempo real)",
      "enforced": true,
      "details": [
        "Validar ESLint antes de finalizar cÃ³digo.",
        "Formatear con Prettier en tiempo real (como si el hook ya hubiera actuado).",
        "No generar cÃ³digo que requiera `--no-verify` para commitear.",
        "No dejar archivos con cambios innecesarios en `staged` (como logs, .env, test.mocks.ts)."
      ]
    },
    {
      "description": "Manejo estricto de tipos en TypeScript",
      "enforced": true,
      "details": [
        "Todos los props, inputs, outputs y funciones deben estar tipados.",
        "Nunca usar `any` global, `unknown` preferible si no se puede determinar.",
        "En tests, los mocks deben usar `MockInstance<ReturnType, Args>` explÃ­cito.",
        "Evitar uso de `as unknown as X` salvo en casos documentados.",
        "Evitar `// @ts-ignore`, usarlo solo si hay justificaciÃ³n clara en comentario."
      ]
    },
    {
      "description": "Pruebas (tests unitarios, integraciÃ³n, mocks)",
      "enforced": true,
      "details": [
        "Usar Vitest y los helpers del sistema STRATO.",
        "No generar asserts triviales o sin valor (como `expect(true).toBe(true)`).",
        "Mocks deben tener retorno vÃ¡lido y tipo correcto (`MockInstance`).",
        "No dejar tests con `skip`, `todo` o `only` al finalizar.",
        "Tests deben cubrir flujos positivos y negativos."
      ]
    },
    {
      "description": "Naming y estructura STRATO",
      "enforced": true,
      "details": [
        "Los servicios terminan en `.service.ts`, controladores en `.controller.ts`, rutas en `.routes.ts`.",
        "Los tests terminan en `.test.ts` o `.test.tsx` segÃºn corresponda.",
        "Las factories terminan en `.factory.ts` y se colocan en `__tests__/`.",
        "NingÃºn archivo debe exceder 300 lÃ­neas sin justificaciÃ³n."
      ]
    }
  ]
}
```

> **Nota:** Cualquier PR que no cumpla estas reglas serÃ¡ bloqueado por CI/pre-commit y deberÃ¡ ser corregido antes de mergear. 